---
title: "Méthodologie pour attribuer un revenu aux ménages"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

La bonne version est une combinaison de la version qui est sur le macbook air et de celle qui est sur github !!!!

# Introduction

Ce document a pour objectif de proposer une méthode pour l'ajout de la variable revenue à une population synthétique qui ne contient pas cette variable. En revanche, il est connu les déciles de cette variable pour certaines variables qualitatives. Cette méthode est implémentée en R. Elle est donnée sous la forme d'un exemple qui permet de tester différentes méthodologies. Dans la suite, nous présentons le cas d'étude, puis la méthodologie et enfin son application sur le cas étudié.

# Le cas d'étude: 

A Prendre la version qui est sur le macbook air et qui génère directementla population synthétique.

Ce que je propose est d'utiliser une loi normale tronquée entre Rmin et Rmax puis de calculer ensuite les déciles
en utilisant  rtnorm du package msm avec Rmin et Rmax et en utilisant 
la moyenne



sur l'iris, en faisant l'hypothèse de l'identité entre la personne de référende fiscale et la personne de référence du recensemsent, nous avons 20 ménages dont la personne de référence a entre 0 et 30 ans, 
Moyenne de 12 000 ecart type de 3 000 avec Rmin et Rmax
4/10 de taille 1 revenu 
3/10 de talle 2 revenu x 2 + 1 000
2/10 de taille 3 revenu x 2 + 2 000 
1/10 de taille 4 revenu x 2 + 3 000

70 qui ont entre 30 et 60 ans
Moyenne de 15 000 avec un ecart type de 4 000 avec Rmin et Rmax
1/10 de taille 1 revenu 
2/10 de talle 2 revenu x 2 + 2 000
3/10 de taille 3 revenu x 2 + 4 000 
4/10 de taille 4 revenu x 2 + 6 000


et 10 qui sont supérieur à 60 ans.
Moyenne de 13 000 ecart type de 5 000 avec Rmin et Rmax
4/10 de taille 1
4/10 de taille 2 revenu x2 + 1000
1/10 de taille 3 revenu x2 + 2000
1/10 de taille 4 revenu x3 + 3000


pour ceux dont la personne de référende est entre 0 et 30 ans, les 9 déciles sont les valeurs suivantes se reproduisent ainsi
5000,  10000, 15000, 16000, 17000, 18000, 20000, 22000, 250000
pour ceux qui ont entre 30 et 60 ans, on augmente de 5000
et pour ceux qui sont à la retraite, on prend les 4 premiers déciles des jeunes et les 5 suivants des personnes actives

```
M_a=c('moins_de_30ans', '30-60ans','plus_de_60ans') # Modalite age
M_t=c('1', '2','3','4_et_plus') # Modalite taille
C=expand.grid(a=M_a,t=M_t,p=0,r=0,std=0) # tableau de contingence
n=100 # N doit être divisible par 100
rmin=5000
rmax=10*rmin

pa1=0.2 # proportion de personnes ayant l'age 1
ra1=12000
da1=1000
stda1=3000

C[C$a==M_a[1] & C$t==M_t[1],]$p=pa1*4/10 
C[C$a==M_a[1] & C$t==M_t[1],]$r=ra1 
C[C$a==M_a[1] & C$t==M_t[1],]$std=stda1

C[C$a==M_a[1] & C$t==M_t[2],]$p=pa1*3/10 
C[C$a==M_a[1] & C$t==M_t[2],]$r=2*ra1+da1
C[C$a==M_a[1] & C$t==M_t[2],]$std=stda1

C[C$a==M_a[1] & C$t==M_t[3],]$p=pa1*2/10 
C[C$a==M_a[1] & C$t==M_t[3],]$r=2*ra1+2*da1
C[C$a==M_a[1] & C$t==M_t[3],]$std =stda1

C[C$a==M_a[1] & C$t==M_t[4],]$p=pa1*1/10 
C[C$a==M_a[1] & C$t==M_t[4],]$r=2*ra1+3*da1
C[C$a==M_a[1] & C$t==M_t[4],]$std=stda1



pa2=0.7 # proportion de personnes ayant l'age 2
ra2=15000
da2=2000
stda2=4000

C[C$a==M_a[2] & C$t==M_t[1],]$p=pa2*1/10 
C[C$a==M_a[2] & C$t==M_t[1],]$r=ra2 
C[C$a==M_a[2] & C$t==M_t[1],]$std=stda2

C[C$a==M_a[2] & C$t==M_t[2],]$p=pa2*2/10 
C[C$a==M_a[2] & C$t==M_t[2],]$r=2*ra2+da2
C[C$a==M_a[2] & C$t==M_t[2],]$std=stda2

C[C$a==M_a[2] & C$t==M_t[3],]$p=pa2*3/10 
C[C$a==M_a[2] & C$t==M_t[3],]$r=2*ra2+2*da2
C[C$a==M_a[2] & C$t==M_t[3],]$std =stda2

C[C$a==M_a[2] & C$t==M_t[4],]$p=pa2*4/10 
C[C$a==M_a[2] & C$t==M_t[4],]$r=2*ra2+3*da2
C[C$a==M_a[2] & C$t==M_t[4],]$std=stda2





pa3=0.1 # proportion de personnes ayant l'age 3
ra3=13000
da3=1000
stda3=5000

C[C$a==M_a[3] & C$t==M_t[1],]$p=pa3*4/10 
C[C$a==M_a[3] & C$t==M_t[1],]$r=ra3 
C[C$a==M_a[3] & C$t==M_t[1],]$std=stda3

C[C$a==M_a[3] & C$t==M_t[2],]$p=pa3*4/10 
C[C$a==M_a[3] & C$t==M_t[2],]$r=2*ra3+da3
C[C$a==M_a[3] & C$t==M_t[2],]$std=stda3

C[C$a==M_a[3] & C$t==M_t[3],]$p=pa3*1/10 
C[C$a==M_a[3] & C$t==M_t[3],]$r=2*ra3+2*da3
C[C$a==M_a[3] & C$t==M_t[3],]$std =stda3

C[C$a==M_a[3] & C$t==M_t[4],]$p=pa3*1/10 
C[C$a==M_a[3] & C$t==M_t[4],]$r=2*ra3+3*da3
C[C$a==M_a[3] & C$t==M_t[4],]$std=stda3
 
library("msm")

popp=c();
for (o in M_a) {
  for (oo in M_t){
    nn = round(n*C[C$a==o & C$t==oo,]$p,0)
    rr = C[C$a==o & C$t==oo,]$r
    stdd=C[C$a==o & C$t==oo,]$std
    poppp=cbind(c(rep(o,nn)), c(rep(oo,nn)), c(round(rtnorm(nn, mean=rr, sd=stdd, lower=rmin, upper=rmax),0)), c(rep(0,nn)))
    popp=rbind(popp, poppp)
  } # fin for oo 
  } # fin for o
pop=data.frame(a=as.factor(popp[,1]),t=as.factor(popp[,2]),r=as.integer(popp[,3]), rp=as.integer(popp[,4]) )


# construction des déciles
Deciles=(1:9)/10
Da=c()
for (o in M_a) {
  Data=pop[pop$a==o,]$r
  Daa=c(o,round(quantile(Data,Deciles),0)) 
  Da=rbind(Da,Daa)
}

Dt=c()
for (o in M_t) {
  Data=pop[pop$t==o,]$r
  Dtt=c(o,round(quantile(Data,Deciles),0)) 
  Dt=rbind(Dt,Dtt)
}




```
```
data_iris_age=data.frame(age=factor(),effectif=integer())
modalite_age=c('moins_de_30ans', '30-60ans','plus_de_60ans')
data_iris_age=rbind(data_iris_age,c(modalite_age[1],20), c(modalite_age[2],70), c(modalite_age[3],10))
colnames(data_iris_age)=c('age','effectif')


decile_0_30ans=c(5000,  10000, 15000, 16000, 17000, 18000, 20000, 22000, 25000)
carriere=5000
decile_30_60ans=decile_0_30ans+carriere
pauvre=1:4
riche=5:9
decile_60_100ans=c(decile_0_30ans[pauvre], decile_30_60ans[riche])

data_fisc_age=rbind(c(modalite_age[1],decile_0_30ans), c(modalite_age[2],decile_30_60ans), c(modalite_age[3],decile_60_100ans))
colnames(data_fisc_age)=c('age','d1','d2','d3','d4','d5','d6','d7','d8','d9')

```

sur l'iris, en faisant l'hypothèse de l'identité entre la personne de référende fiscale et la personne de référence du recensemsent, nous avons 10 ménages dont la taille de personne est 1
50 sont la taille est 2, 30 dont la taille est 3
et 10 qui sont supérieur à 3.
pour ceux dont la taille est 1  les 9 déciles sont les valeurs suivantes se reproduisent ainsi
5000,  10000, 15000, 16000, 17000, 18000, 20000, 22000, 250000 + 1000
pour ceux dont la taille est 2   on multiplie par 2
pour ceux dont la taille est 3   on augmente de 1000
pour ceux dont la taille est  supérieur à 3   on augmente de 1000
on prend les 4 premiers déciles de la taille 2 et les 5 suivants de la taille 3

```
data_iris_taille=data.frame(taille=factor(),effectif=integer())
modalite_taille=c('1', '2','3','4_et_plus')
data_iris_taille=rbind(data_iris_taille,c(modalite_taille[1],20), c(modalite_taille[2],50), c(modalite_taille[3],30), c(modalite_taille[4],10))
colnames(data_iris_taille)=c('taille','effectif')


decile_1=c(5000,  10000, 15000, 16000, 17000, 18000, 20000, 22000, 25000)+1000
decile_2=decile_1*2
decile_3=decile_2+1000
pauvre=1:4
riche=5:9
decile_4_et_plus=c(decile_1[pauvre], decile_3[riche])
data_fisc_taille=rbind(c(modalite_taille[1],decile_1), c(modalite_taille[2],decile_2), c(modalite_taille[3],decile_3),  c(modalite_taille[4],decile_4_et_plus))

colnames(data_fisc_taille)=c('taille','d1','d2','d3','d4','d5','d6','d7','d8','d9')
```


# Méthodologie

Note : dans la suite r signifie : le revenu est inférieur à r. a signie : l'age de la personne de référence du ménage est égale à la modalité a. t signifie la taille du ménage est égale à la modalité t. 

Nous souhaitos connaitre pour tout revenu, r,compris entre le revenu minimal, rmin, la probabilité que le revenu soit inférieur à r sachant que la taialle du ménage est t et l'age de la personne du ménage est a. Ce qui s'écrit mathématiquement :

$$ P(r \; | \; (\text{a et t})) $$
En appliquant le théorème de Bayes, nous obtenons

$$P(r \; | \; (\text{a et t}))=P((\text{a et t}) \; | \; r) \frac{P(r)}{P(\text{a et t})}$$
Une règle de trois sur la population synthétique permet  de connnaitre
$$P(\text{a et t})$$
La connaissance des déciles sur le revenu et la proportion de chacune des modalité permet de connaitre 
$$P(r_k) = \sum_i P(r_k| a_i)P(a_i)$$
rk est le revenu correspondant au décile k (k=0.1,0.2,0.3,...1), al correspont à la modalité l de l'age de la personne de référence du ménage

On peut aussi faire le calcul avec les modalités sur la taille : 

$$P(r_l) = \sum_j P(r_l| t_j)P(t_j)$$
Même si rk et rl sont différents, il est intéressant de calculer ces 20 valeurs pour vérifier visuellement leurs cohérences.

Ensuite, il faut estimer 
$$P((\text{a et t}) \; | \; r)$$
Pour cela, nous allons utiliser la méthodologie de l'entropie croisée : nous allons considérer que cette probabilité doit être la plus proche de P(a et t)
tout en respectant les déciles P(rl sachant ai) pour tout l et pour tout i et P(rk schant tj) pour tout k et pour tout j.

Nous allons calculer P( a et t sachant r) pour r valant rk ou rl. Sachant qu'il y a 20 déciles,  3 modalité pour l'age de la personne du référence du ménage et 4 modalités pour la taille du ménages, nous avons 240 degrés de libertés



Concrêtement, pour connaitre par exemple, P ((a et t) sachant r1) où r1 correspond au revenu du  premier décile lorsque l'age de référence est égale 

$$ Min \; -\sum_{i,j,k,l} P(\text{ai et tj} \; | \; r_{k,l}) \ln(P(\text{a_i et t_j})) $$
sous les contraintes

$$P(r_k \; | \; a_i) =k\times 0.1$$
$$P(r_l \; | \; t_j) =l\times 0.1$$
soit 70 contraintes

Dans la suite, nous nous concentrons sur une contrainte pour voir sa relation avec les degrés de liberté:
$$P(r_1 \; | \; a_1) = P(a_1 \; | \; r_1)\frac{P(r_1)}{P(a_1)} $$ 
P(a1) est un maginal de la population synthétique. P(r1) a été calculé précedemment et P(a1 sachant r1) s'écrit en fonction des degrés de liberté:

$$P(a_1 \; | \; r_1) = P(a_1 \text{ et } b_1| \; r_1) + P(a_1 \text{ et } b_2| \; r_1) + P(a_1 \text{ et } b_3| \; r_1) + P(a_1 \text{ et } b_4 | \; r_1) $$

Ce problème d'optimisation peut être diviser en 20 problèmes de minimisations indépendants comprenant chacun 12 degrés de liberté et 1 contrainte.
Par exemple, en choisissant de travailler sur r1.

$$ Min \; -\sum_{i,j} P(\text{ai et tj} \; | \; r_{1}) \ln(P(\text{ai et tj}))$$

Si on appel P chapeau la solution du problème d'optimisation, nous trouvons

$$P(r1 \; | \; (\text{ai et tj}))=\widehat{P}((\text{ai et tj}) \; | \; r1) \frac{P(r1)}{P(\text{ai et tj})}$$
Après avoir réalisé les 20 optimisations, nous aurons

$$P(r_{k,l} \; | \; (\text{ai et tj}))$$
pour tout k et pour tout l. En faisant une interpolation linéaire entre les valeurs rk, rl, nous obtenons la loi de probabilité du revenu connaissant ai et tj et donc, nous pouvons tirer un revenu au hasard pour tous les couples (ai, tj)



# Application

En cours de développement....
Utiliser MinxEnt de R.

Mise en oeuvre : 
partir de l'IRIS avec les revenus


```
R=20000
age=modalite_age[1]
taille=modalite_taille[1]
p=c(1:9)/10
data_iris_taille[modalite_taille[1],2:]
PRAge=data.frame(p)
```
